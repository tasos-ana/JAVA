# [Part1.1](https://github.com/tasos-ana/JAVA/tree/master/Basic/part1.1)
## Παλινδρομικές Φράσεις
### Input/Output, Πίνακες

Καλείστε να γράψετε πρόγραμμα το οποίο θα αποφασίζει αν ένα αλφαριθμητικό είναι παλινδρομικό 
δηλαδή αν διαβάζοντας το ανάποδα παίρνουμε το ίδιο αλφαριθμητικό 
Παραδείγματα παλινδρομικών αναγνωριστικών ακολουθούν: **«abcba»**,  **«A man, a plan, a canal: Panama»**, ή 
το πιο γνωστό **«Νίψον ανομήματα μη μόναν όψιν»**. 

Συγκεκριμένα, το πρόγραμμα θα ζητάει από το χρήστη να εισάγει μια φράση και αυτό θα του επιστρέφει ανάλογο μήνυμα 
για το εάν η φράση είναι παλινδρομική ή όχι. Για να το επιτύχετε μετατρέψετε το αλφαριθμητικό που δίνεται  σαν είσοδος 
από το χρήστη σε δύο πίνακες από χαρακτήρες. Ο πρώτος θα περιεχέι όλους τους χαρακτήρες της φράσης με τη σειρά που 
τους εισήγαγε ο χρήστης ενώ ο δεύτερος τους χαρακτήρες αυτούς ανάποδα.  
Επίσης το πρόγραμμα σας πρέπει να μετράει πόσο χρόνο του πήρε για να κάνει αυτόν τον έλεγχο

**Προσοχή**: οι ειδικοί χαρακτήρες και τυχόν κεφάλαια γράμματα θα πρέπει να αγνοούνται.

<details><summary>Read More</summary>
<p>
Υποδείξεις:  

- Για να διαβάζετε την είσοδο stdin :
      
      Scanner in = new Scanner(System.in); 
      String nextLine = in.next(); 
      int aNumber = in.nextInt(); 

- Για να μετράτε τον χρόνο σε nano seconds χρησιμοποιείστε  :

      long time = System.nanoTime(); 
  
- Για τον έλεγχο τον κεφαλαίων γραμμάτων και των ειδικών χαρακτήρων, χρήσιμες μεθόδους θα βρείτε στο API της κλάσης String
(http://docs.oracle.com/javase/6/docs/api/java/lang/String.html)
</p></details>


# [part1.2](https://github.com/tasos-ana/JAVA/tree/master/Basic/part1.2)
## Fractals
### Classes, Arrays, Strings, Recursion, Files

Καλείστε να γράψετε ένα αναδρομικό πρόγραμμα Java το οποίο θα φτιάχνει ένα fractal (μορφόκλασμα) με τρίγωνα όπως το εξής: 

<p align="center"> <img src="part1.2/fractal.png"> <p>

**α) Δημιουργία Στοιχειώδους Κλάσης**

Στο πρώτο βήμα θα πρέπει να υλοποιήσετε μια κλάση "Pixel" η οποία θα πρέπει να υλοποιεί τις παρακάτω συναρτήσεις.
<details><summary>Read More</summary>
<p>
      
      import java.awt.Color;
      /*
      *Pixel constructor
      *@x,y pixel cordinates
      *@color the color of the pixel
      */
      
      public Pixel(int x, int y, Color color); 
      
      /*
      *modifiers
      */
      public void setX(int x);
      public void setY(int y);
      public void setColor(Color color);
      
      /*
      * accessors
      */
      public int getX();
      public int getY();
      public Color getColor();
 
 Δηλαδή να έχει απλά τα απαραίτητα ιδιωτικά μέλη τα οποία διαχειρίζονται οι παραπάνω μέθοδοι. 


**β) Χρήση Κλάσης που μας δίδεται, Strings, Αρχεία**

Για το δεύτερο βήμα σας δίδεται η κλάση "Picture" την οποία θα χρησιμοποιήσετε για να εμφανίσετε τις εικόνες που θα δημιουργεί το πρόγραμμά σας. Ένα αντικείμενο τύπου "Picture" δημιουργεί ένα καινούργιο γραφικό παράθυρο, και οι μέθοδοι της κλάσης αυτής που θα χρειαστεί να χρησιμοποιήσετε είναι οι ακόλουθες: 

      Picture(int w, int h)   //make a new Canvas w pixels width and h pixels height
      set(Pixel pixel)        // draw a pixel into the Canvas. Uses the class you defined in (a)  
      show()                  //show the result on the window
      setOriginLowerLeft()    //the 0,0 pixel is on the bottom left
      setOriginUpperLeft()    //the 0,0 pixel is on the top left
      
Σας δίδεται επίσης ένα αρχείο με ονομασία fractal.txt του οποίου κάθε γραμμή κρατάει πληροφορία για ένα pixel στην εξής μορφή:
      
      (cordinates) (color of the pixel as triples of Red Green Blue values) 
      x       y       Red         Green       Blue 

όπου όλες οι τιμές είναι ακέραιες.  Τώρα δημιουργήστε μία δική σας κλάση με όνομα ReadImageFromTxtFile της οποίας η main θα διαβάζει το αρχείο και θα αναπαριστά (ζωγραφίζει) το περιεχόμενό του χρησιμοποιώντας την κλάση "Pixel" του ερωτήματος (α) και την κλάση "Picture". 

**Προσοχή**: για να αναπαρασταθεί σωστά το περιεχόμενο του  fractal.txt θα πρέπει να έχετε θέσει σωστά το σύστημα συντεταγμένων με τη setOriginUpperLeft(). Επίσης ο Canvas πρέπει να είναι Ν*Ν όπου Ν=512 pixels. 

**γ) Πίνακες, αντικείμενα, αναδρομικές συναρτήσεις**

Τώρα δημιουργήστε μία δική σας κλάση με όνομα RecursiveTriangle. Στη main αυτής της κλάσης ορίστε ένα αντικείμενο τύπου Picture. Επίσης ορίστε έναν  διδιάστατο πίνακα από αντικείμενα τύπου "Pixel"  με τα οποία θα αναπαραστήσετε αυτό που θα ζωγραφίσετε (θέτοντας το χρώμα τους). Για να ορίσετε το χρώμα των pixels της ζωγραφιάς σας θα χρειαστεί να φτιάξετε μία αναδρομική (recursive) μέθοδο που θα υλοποιεί τον ακόλουθο αναδρομικό αλγόριθμο. 
      
Η ιδέα είναι απλή. Αρχικά έχετε 3 σημεία (p1, p2, p3) που ορίζουν τις κορυφές ενός τριγώνου (του μεγαλύτερου στη ζωγραφιά μας).  Μπορούμε μέσα του να ζωγραφίσουμε άλλα τρία μικρότερα τρίγωνα με τον εξής απλό τρόπο: για κάθε ζευγάρι κορυφών βρίσκουμε το μέσο τους, ήτοι υπολογίζουμε τις συντεταγμένες των σημείων (p1+p2)/2,  (p2+p3)/2 και (p1+p3)/2.  Με αυτά τα σημεία και τις κορυφές του τριγώνου μπορείτε να ζωγραφίσετε 3 νέα μικρότερα τρίγωνα (δείτε το παραπάνω σχήμα).  Συνεχίζετε (αναδρομικά) την ίδια διαδικασία για τα 3 μικρά τρίγωνα, κ.ο.κ, έως ότου τα τρίγωνα προς σχεδίαση έχουν γίνει πολύ μικρά (π.χ. οι 3 κορυφές έχουν τις ίδιες συντεταγμένες). Προσοχή: Ο canvas εξαρχής (by default)  είναι μαύρος. 
Υποδείξεις:  
      
      Integer.parseInt(String str); (static function) 
      File (class) 
      FileReader (class) 
      BufferedReader (class) 
</p></details>


# [part1.3](https://github.com/tasos-ana/JAVA/tree/master/Basic/part1.3)
## Text Indexing for Information Retrieval
### String, File, I/O, Arrays

Στόχος της άσκησης είναι να φτιάξετε ένα απλό Σύστημα Ανάκτησης Πληροφοριών (Information Retrieval System) από αρχεία κειμένου. 

**α) Ο Ευρετηριαστής**

Γράψτε ένα πρόγραμμα Java το οποίο θα ζητάει από το χρήστη να δώσει από τη γραμμή εντολών το όνομα ενός αρχείου εισόδου και το όνομα ενός αρχείου εξόδου. Στη συνέχεια αφού διαβάσει το αρχείο εισόδου το πρόγραμμα θα πρέπει να δημιουργεί στο αρχείο εξόδου ένα «ευρετήριο λέξεων». Ένα «ευρετήριο λέξεων» περιέχει όλες τις διαφορετικές λέξεις του αρχείου εισόδου (κάθε λέξη σε διαφορετική γραμμή) και για κάθε λέξη εμφανίζει τις θέσεις στις οποίες βρέθηκε στη μορφή «γραμμή;θέση». Οι λέξεις στο ευρετήριο πρέπει να είναι σε πεζά γράμματα (lowercase) και να μη λαμβάνουν υπόψη ειδικούς χαρακτήρες στην αρχή ή στο τέλος της κάθε λέξης. 
Για παράδειγμα, για το αρχείο εισόδου: 
<details><summary>Read More</summary><p>

      my name is George, 
      your name is Nick 
      and we love Java.
     
Θα πρέπει να δημιουργείτε στο αρχεία εξόδου το παρακάτω ευρετήριο: 
      
      my 1;1 
      name 1;4,2;6 
      is 1;9,2;11 
      george 1;12       (προσέξτε, όχι “george,”) 
      your 2;1 
      nick 2;14  
      and 3;1 
      we 3;5 
      love 3;8 
      java 3;13         (προσέξτε, όχι “java.”) 
     
**β) Χρήση Ευρετηρίου**

Γράψτε ένα πρόγραμμα Java το οποίο θα ζητάει από το χρήστη να δώσει από την γραμμή εντολών τη διεύθυνση ενός αρχείου κειμένου, τη διεύθυνση του αρχείου που έχει το  ευρετηρίου λέξεων, ένα String αναζήτησης και ένα ακέραιο N. 
Κάνοντας χρήση του ευρετηρίου θα επιστρέφει ένα ή περισσότερα αποσπάσματα μήκους το πολύ N που περιέχουν αυτήν την λέξη (αν φυσικά υπάρχει η λέξη στο ευρετήριο). Ένα απόσπασμα (snippet) είναι ένα κομμάτι του κειμένου το οποίο περιέχει τη λέξη που δόθηκε. Για παράδειγμα, στη περίπτωση που ο χρήστης δώσει τη λέξη «Nick», ένα απόσπασμα (με μήκος 24 χαρακτήρες) είναι το παρακάτω: 

       «name is Nick and we love» 
       
Θεωρήστε ότι το String αναζήτησης που δίνει ο χρήστης πρέπει να περιέχει μία μόνο λέξη. 
Τέλος, στη περίπτωση που η λέξη δε βρεθεί, το πρόγραμμα πρέπει να εμφανίζει το παρακάτω κείμενο: 

      «No results for the given query!» 

**γ) Γενίκευση του Ευρετηριαστή** 

Επεκτείνετε τα ερώτημα α) ώστε το πρόγραμμα να ζητάει από το χρήστη να δώσει από τη γραμμή εντολών το όνομα ενός φακέλου (αντί ενός αρχείου εισόδου). Στη συνέχεια αφού διαβάσει όλα τα αρχεία κειμένου που περιέχονται στον φάκελο, το πρόγραμμα θα δημιουργεί  στο αρχείο εξόδου ένα «ευρετήριο λέξεων» που όμως πλέον θα περιέχει για κάθε λέξη και τα αρχεία στα οποία βρέθηκε στη μορφή «αρχείο;γραμμή;θέση» όπως παρακάτω: 

      and example1.txt;3;1 
      george example2.txt;1;12  
      is example1.txt;1;9,example2.txt;2;11 


**δ) Χρήση Ευρετηρίου**

Επεκτείνετε το ερώτημα β) ώστε να επιστρέφει μαζί με τα αποσπάσματα και τα αρχεία στα οποίο βρέθηκε η λέξη, όπως παρακάτω: 

      example1.txt 
      «name is Nick and we love» 

      example2.txt 
      «called Nick and ask to» 

Το πρόγραμμα θα ζητάει από το χρήστη να δώσει από την γραμμή εντολών τη διεύθυνση ενός ευρετηρίου λέξεων (όπως αυτό που παράγεται από το ερώτημα γ), ένα αντικείμενο τύπου String και ένα ακέραιο N (για το μέγιστο μήκος του snippet). Θεωρήστε πάλι ότι το String αναζήτησης που δίνει ο χρήστης πρέπει να περιέχει μία μόνο λέξη. 


**ε)Κατέβασμα και Ευρετηρίαση κειμένων από το διαδίκτυο**

Επεκτείνετε τα ερώτημα α) ώστε το πρόγραμμα να ζητάει από τον χρήστη να δώσει από την γραμμή εντολών το URL μιας ιστοσελίδας (αντί ένα αρχείο κειμένου). Το πρόγραμμα θα διαβάζει το περιεχόμενο της σελίδας (το οποίο συνήθως είναι σε HTML μορφή) και θα δημιουργεί στο αρχείο εξόδου ένα «ευρετήριο λέξεων» για τη συγκεκριμένη σελίδα. 

Το παρακάτω τμήμα Java κώδικα τυπώνει το περιεχόμενο μιας ιστοσελίδας: 
      
      String urlStr = "http://en.wikipedia.org/wiki/Yellowfin_tuna"; 
      URL url = new URL(urlStr); 
      URLConnection con = url.openConnection(); 
      BufferedReader in = new BufferedReader( 
            new InputStreamReader(con.getInputStream(), "UTF-8")); 
      String pageContents = ""; 
      String input; 
      while ((input = in.readLine()) != null) { 
            pageContents = pageContents + input + "\n"; 
      } 
      in.close(); 
      System.out.println(pageContents); 

Πριν την ευρετηρίαση, προσπαθήστε να αφαιρέσετε HTML κώδικα που δε χρησιμεύει σε μία αναζήτηση (δηλαδή κείμενο που περιέχεται σε “<” και “>”). Πχ για το κείμενο “my name is <font color=’blue’>George</font>”, θέλουμε να ευρετηριάσουμε μόνο τις λέξεις του κειμένου “my name is George”, δηλαδή όχι τις λέξεις font, color, blue, κτλ. 

</p></details>


# [part2.1](https://github.com/tasos-ana/JAVA/tree/master/Basic/part2.1)
## Τμήματα και Σπουδαστές
### Δημιουργία πολλών συνδεδεμένων κλάσεων

**α)** Ορίστε μία κλάση Person με τα εξής "πεδία": όνομα (String),  επώνυμο (String) και αριθμό ταυτότητας (String). Ορίστε μία κλάση Department με τα εξής πεδία:  όνομα (String), και community το οποίο θα είναι πίνακας που θα μπορεί να κρατάει  αντικείμενα τύπου  Person. Ορίστε μία κλάση Student που να εξειδικεύει την Person και έχει δύο επιπλέον πεδία: ένα πεδίο  AM (String),  και ένα department του οποίου η τιμή μπορεί να είναι ένα στιγμιότυπο της κλάσης Department. Ορίστε μία κλάση GradStudent που να εξειδικεύει την Student και να έχει ένα πεδίο thesisArea (String). 
Λάβετε υπόψη σας τα εξής: 

<details><summary>Read More</summary><p>
      
- Τα πεδία όλων των παραπάνω κλάσεων πρέπει να είναι ιδιωτικά (private).
- Όλες οι κλάσεις πρέπει να έχουν  μία μέθοδο toString() η οποία να εκτυπώνει τα αντίστοιχα στοιχεία (π.χ. για έναν GradStudent, το  όνομα, επώνυμο, αριθμό ταυτότητας (String), ΑΜ, το όνομα του Τμήματος στο οποίο σπουδάζει, και τη θεματική  περιοχή της διατριβής του.
- Όλες οι κλάσεις πρέπει να έχουν  μία κατασκευάστρια μέθοδο η οποία να παίρνει τις τιμές που χρειάζεται. Η κατασκευάστρια της Department θα λαμβάνει ως παράμετρο μόνο το όνομα του Department. Επίσης πρέπει να προσφέρει μεθόδους για την προσθήκη και διαγραφή σπουδαστών, συγκεκριμένα μία  add(Student) και μία delete(AM).
      
Για να δοκιμάσετε τα παραπάνω,  ορίστε μια κλάση UnivTester της οποίας η main()  θα δημιουργεί δύο στιγμιότυπα  του Department  και θα προσθέτει σε κάθε ένα από αυτά 200 προπτυχιακούς και 24 μεταπτυχιακούς (διαφορετικούς). Μετά θα καλεί την toString() του κάθε τμήματος αυτού η οποία θα πρέπει να εμφανίζει τα στοιχεία του τμήματος, δηλαδή το όνομά του, και τα στοιχεία των μελών του (συγκεκριμένα θα καλείται η  toString() σε κάθε στοιχείο του πίνακα community). 

**β)**
Επίσης κάντε ό,τι επέκταση σας φαίνεται λογική και χρήσιμη ώστε: 
(α) να υπάρχει ένα φαινόμενο  shadowing και  
(β) να υπάρχει κάτι (πεδίο ή μέθοδος) static. 
Σημειώστε το τι κάνατε για αυτό το θέμα μέσα στον κώδικα με σχόλια. 

</p></details>


# [part2.2](https://github.com/tasos-ana/JAVA/tree/master/Basic/part2.2)
## Απλός Πυρήνας για Παιχνίδια Ρόλων (core for Role Playing Games) 
### Interfaces, Inheritance, Subclasses, Collaborating Objects

[Read More](https://github.com/tasos-ana/JAVA/blob/master/Basic/part2.pdf)


# [part2.3](https://github.com/tasos-ana/JAVA/tree/master/Basic/part2.3)
## Person again
### Τεκμηρίωση και έλεγχος ADTs  (Javadoc, Junit).

Κάντε ένα αντίγραφο της κλάσης Person που κάνατε στην 1η άσκηση που είχε τα ιδιωτικά μέλη όνομα (String),  επώνυμο (String) και αριθμό ταυτότητας (String). Προσθέστε ένα στατικό πεδίο numberOfPersons το οποίο πρέπει να κρατά τον αριθμό των προσώπων που έχουν δημιουργηθεί. 

Ορίστε ένα πλήρες σύνολο μεθόδων (constructors, accessors, transformers) λαμβάνοντας υπόψη σας και τα εξής: 

- τα ονόματα να έχουν μόνο έγκυρους (για ονόματα ανθρώπων) χαρακτήρες
- ο αριθμός ταυτότητας να έχει πάντα 8 χαρακτήρες: 2 γράμματα στην αρχή και κατόπιν έξι ψηφία.
- ο αριθμός numberOfPersons πρέπει να έχει την ορθή τιμή.

Σε περίπτωση που κληθεί  μία δημόσια μέθοδος με παράμετρο που δεν πληροί τους παραπάνω κανόνες τότε  ο κώδικας σας να εγείρει ένα IllegalArgumentException. 


# [part2.4](https://github.com/tasos-ana/JAVA/tree/master/Basic/part2.4)
## Βιβλιοθήκη
### [ADTs, overloading, pre/postconditions-invariants, Javadocs, JUnit Tests] 

Σε αυτή την άσκηση καλείστε να υλοποιήσετε ένα πολύ απλό σύστημα διαχείρισης βιβλιοθήκης. Θα χρειαστεί να υλοποιήσετε τέσσερεις Αφαιρετικούς Τύπους Δεδομένων (ΑΤΔ):  

- Βιβλίο (Book),
- Αντίτυπο (Copy),
- Βιβλιοθήκη (Library) και
- Μέλος (Member).

οι οποίοι προφανώς συνδέονται μεταξύ τους (ένα βιβλίο έχει αντίτυπα τα οποία μία βιβλιοθήκη δανείζει στα μέλη της), και θα περιγραφούν αναλυτικά παρακάτω. 

Επίσης καλείστε να: 

- τεκμηριώσετε πλήρως τον κώδικά σας με τη βοήθεια των Javadocs

- υλοποιήσετε τις αμετάβλητες συνθήκες  (invariants)  των κλάσεων που θα υλοποιήσετε και τις εκ των προτέρων και  εκ των υστέρων συνθήκες (preconditions, postconditions) των μεθόδων τους. Οι συνθήκες αυτές θα πρέπει να ορίζονται σαφώς στην τεκμηρίωση μέσω Javadocs για κάθε μέθοδο, καθώς επίσης τα preconditions θα πρέπει να ελέγχονται με χρήση exceptions.

- να χρησιμοποιήσετε μηχανισμούς ελέγχου ορθότητας του κώδικά σας, μέσω JUnit Tests για τις μεθόδους των ΑΤΔ Book και Copy.

Ακολουθούν οι ιδιότητες και τα χαρακτηριστικά των ΑΤΔ που καλείστε να σχεδιάσετε και να υλοποιήσετε: 

[Read More](https://github.com/tasos-ana/JAVA/blob/master/Basic/part2.pdf)
